<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>1-bit Image Converter</title>
<style>
  :root{
    --bg:#0b1220; --card:#121a2a; --ink:#d6e1ff; --muted:#93a0c6; --accent:#5aa2ff; --warn:#ff6b6b;
    --touch:14px; /* extra padding for touch */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{position:sticky;top:0;z-index:10;padding:12px 14px;border-bottom:1px solid #1f2a44;display:flex;align-items:center;gap:8px;background:linear-gradient(0deg,rgba(11,18,32,.85),rgba(11,18,32,.95))}
  header h1{margin:0;font-size:16px;font-weight:600}
  header .hint{color:var(--muted);display:none}
  header .spacer{flex:1}
  .iconbtn{border:1px solid #2a4a85;background:#17305e;color:#e7efff;border-radius:10px;padding:8px 12px;cursor:pointer}
  .iconbtn:active{opacity:.9}
  .counter{opacity:.9;margin-left:6px;font-variant-numeric:tabular-nums}
  .banner{display:none;padding:10px 14px;background:#2a0b12;color:#ffd7d7;border:1px solid #5d1d2a}
  .banner.show{display:block}
  main{display:grid;grid-template-columns:280px 1fr;gap:12px;padding:12px;height:calc(100% - 57px)}
  .panel{background:var(--card);border:1px solid #1f2a44;border-radius:14px;padding:12px;overflow:hidden}
  #left{display:flex;flex-direction:column;min-width:0}
  #drop{border:1px dashed #2a3b64;border-radius:12px;padding:14px;text-align:center;color:var(--muted);cursor:pointer;user-select:none}
  #drop.hover{background:#0f1830}
  #fileInput{display:none}
  .thumbs{margin-top:12px;overflow:auto;flex:1;display:grid;gap:8px;grid-template-columns:1fr;padding-right:4px}
  .thumb{position:relative;display:flex;gap:8px;align-items:center;padding:10px;border:1px solid transparent;border-radius:10px;cursor:pointer}
  .thumb.active{border-color:#2f4a80;background:#0f1830}
  .thumb img{width:56px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #23345a}
  .thumb .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:26px}
  .thumb .del{position:absolute;top:6px;right:6px;width:26px;height:26px;border-radius:13px;border:1px solid #2a3b64;background:#0e172b;color:#e7efff;font-weight:700;line-height:22px;text-align:center;cursor:pointer;opacity:.0;transition:opacity .15s}
  .thumb:hover .del,.thumb.active .del{opacity:.95}
  .thumb .del:active{transform:scale(.96)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px}
  .seg{display:flex;background:#0e172b;border:1px solid #223356;border-radius:10px;overflow:hidden}
  .seg button{border:0;background:transparent;color:#e7efff;padding:10px 12px;cursor:pointer}
  .seg button.active{background:#17305e}
  .btn{background:#17305e;border:1px solid #2a4a85;color:#e7efff;padding:10px 14px;border-radius:10px;cursor:pointer}
  .btn.secondary{background:#0e172b;border-color:#223356;color:#d6e1ff}
  input[type="range"]{touch-action:none}
  #right{display:flex;flex-direction:column;min-width:0}
  #canvasWrap{position:relative;flex:1;min-height:360px;background:#0a1020;border:1px solid #1f2a44;border-radius:12px;overflow:hidden;display:flex;align-items:center;justify-content:center}
  #preview{width:100%;height:100%;display:block;touch-action:none}
  footer{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .note{color:var(--muted);font-size:12px}

  /* Drawer for mobile */
  .drawer-mask{position:fixed;inset:0;background:rgba(5,10,20,.5);backdrop-filter:blur(2px);opacity:0;pointer-events:none;transition:opacity .2s;z-index:40}
  .drawer{position:fixed;inset:0 0 0 auto;width:86vw;max-width:380px;background:var(--card);border-left:1px solid #1f2a44;transform:translateX(100%);transition:transform .2s;z-index:41;display:flex;flex-direction:column}
  .drawer header{position:sticky;top:0;z-index:1;background:var(--card);padding:10px 12px;border-bottom:1px solid #1f2a44;display:flex;align-items:center;gap:8px}
  .drawer .close{margin-left:auto}
  .drawer .content{padding:10px;height:100%;display:flex;flex-direction:column}
  body[data-drawer="open"] .drawer{transform:translateX(0)}
  body[data-drawer="open"] .drawer-mask{opacity:1;pointer-events:auto}

  /* Responsive: stack panels and use drawer */
  @media (max-width: 900px){
    header .hint{display:none}
    main{grid-template-columns:1fr;height:auto}
    #left{display:none} /* replaced by drawer */
    #right{min-height:calc(100vh - 57px);}
    .controls{gap:10px}
    .seg button,.btn{padding:12px 14px}
  }
</style>
</head>
<body>
<header>
  <h1>T5 Prep — 1‑bit BMPs</h1>
  <div class="hint">Drop images • per-image settings • live 1‑bit preview</div>
  <div class="spacer"></div>
  <button id="openDrawer" class="iconbtn" aria-haspopup="dialog" aria-expanded="false">Images <span id="imgCount" class="counter">(0)</span></button>
</header>

<div id="banner" class="banner"></div>

<main>
  <!-- Left panel kept for desktop; same content also appears inside drawer for mobile -->
  <section id="left" class="panel">
    <div id="drop">
      <strong>Drop images here</strong> or tap to select<br>
      <small>JPG / PNG / WEBP — multiple OK</small>
    </div>
    <input id="fileInput" type="file" accept="image/*" multiple />
    <div class="thumbs" id="thumbs"></div>
  </section>

  <section id="right" class="panel">
    <div class="controls">
      <div class="seg" title="Orientation / Target Size">
        <button id="portraitBtn" class="active">Portrait 176×264</button>
        <button id="landscapeBtn">Landscape 264×176</button>
      </div>
      <div class="seg" title="Dithering">
        <button id="ditherNone" class="active">No dither</button>
        <button id="ditherFS">Floyd–Steinberg</button>
        <button id="ditherBayer">Ordered 8×8</button>
      </div>
      <label title="Gamma">
        γ
        <input id="gamma" type="range" min="0.6" max="1.8" step="0.05" value="1.0">
        <span id="gammaVal">1.00</span>
      </label>
      <label title="Swap black/white">
        <input id="invert" type="checkbox"> Invert
      </label>
      <button class="btn secondary" id="fitBtn">Fit</button>
      <button class="btn secondary" id="rotL">⟲ Rotate</button>
      <button class="btn secondary" id="rotR">⟳ Rotate</button>
      <span style="flex:1"></span>
      <button class="btn" id="saveOne">Download BMP</button>
      <button class="btn" id="saveZip">Process All → ZIP</button>
    </div>

    <div id="canvasWrap">
      <canvas id="preview"></canvas>
    </div>

    <footer>
      <div class="note">Tip: On mobile, pinch to zoom, drag to pan. Thumbnails live in the Images drawer.</div>
    </footer>
  </section>
</main>

<!-- Drawer (mobile) -->
<div class="drawer-mask" id="drawerMask"></div>
<aside class="drawer" role="dialog" aria-modal="true" aria-label="Images drawer" id="drawer">
  <header>
    <strong>Images</strong>
    <button class="iconbtn close" id="closeDrawer">Close</button>
  </header>
  <div class="content">
    <div id="drop_m">
      <div id="dropMobile" style="border:1px dashed #2a3b64;border-radius:12px;padding:12px;text-align:center;color:#93a0c6;cursor:pointer">
        <strong>Tap to add</strong> or drag here
      </div>
    </div>
    <input id="fileInputMobile" type="file" accept="image/*" multiple style="display:none" />
    <div class="thumbs" id="thumbsMobile" style="margin-top:10px"></div>
  </div>
</aside>

<script>
(function(){
  "use strict";
  const banner = document.getElementById('banner');
  let __warnTimer = null;
  const warn = (msg)=>{
    if(!banner) return;
    banner.textContent = '⚠ ' + msg;
    banner.classList.add('show');
    try{ if(__warnTimer) clearTimeout(__warnTimer); }catch(_){}
    __warnTimer = setTimeout(()=>{ banner.classList.remove('show'); banner.textContent=''; }, 5000);
  };

  // DOM elements (desktop + mobile drawer mirrors)
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const thumbs = document.getElementById('thumbs');
  const dropMobile = document.getElementById('dropMobile');
  const fileInputMobile = document.getElementById('fileInputMobile');
  const thumbsMobile = document.getElementById('thumbsMobile');
  const imgCount = document.getElementById('imgCount');

  const openDrawerBtn = document.getElementById('openDrawer');
  const closeDrawerBtn = document.getElementById('closeDrawer');
  const drawer = document.getElementById('drawer');
  const drawerMask = document.getElementById('drawerMask');

  const portraitBtn = document.getElementById('portraitBtn');
  const landscapeBtn = document.getElementById('landscapeBtn');
  const ditherNone = document.getElementById('ditherNone');
  const ditherFS = document.getElementById('ditherFS');
  const ditherBayer = document.getElementById('ditherBayer');
  const gammaInput = document.getElementById('gamma');
  const gammaVal = document.getElementById('gammaVal');
  const invertChk = document.getElementById('invert');
  const fitBtn = document.getElementById('fitBtn');
  const rotL = document.getElementById('rotL');
  const rotR = document.getElementById('rotR');
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });

  // Drawer helpers
  function setDrawer(open){
    document.body.setAttribute('data-drawer', open ? 'open' : '');
    openDrawerBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }
  openDrawerBtn.addEventListener('click', ()=> setDrawer(true));
  closeDrawerBtn.addEventListener('click', ()=> setDrawer(false));
  drawerMask.addEventListener('click', ()=> setDrawer(false));

  // Shared state
  const state = {
    files: [], // {name,url,img,view:{scale,ox,oy,rot}, settings:{orientation,target,dither,gamma,invert}}
    active: -1,
    target: { w:176, h:264 },
    dither: 'none',
    gamma: 1.0,
    invert: false
  };

  // Canvas sizing
  function sizeCanvas() {
    const r = canvas.parentElement.getBoundingClientRect();
    const w = Math.max(200, Math.floor(r.width));
    const h = Math.max(220, Math.floor(r.height));
    if (w !== canvas.width || h !== canvas.height) {
      canvas.width = w; canvas.height = h; drawPreview();
    }
  }
  window.addEventListener('resize', sizeCanvas, { passive:true });
  setTimeout(sizeCanvas, 0);

  // Utilities
  const exOK = (name)=>/\\.(jpe?g|png|webp|gif|bmp)$/i.test(name||'');
  const countUpdate = ()=> imgCount.textContent = '(' + state.files.length + ')';

  function currentControlsSettings(){
    return {
      orientation: (state.target.w===176 && state.target.h===264) ? 'portrait' : 'landscape',
      target: { w: state.target.w, h: state.target.h },
      dither: state.dither,
      gamma: state.gamma,
      invert: state.invert
    };
  }
  function applySettingsToControlsAndState(settings){
    state.target = { w: settings.target.w, h: settings.target.h };
    state.dither = settings.dither;
    state.gamma = settings.gamma;
    state.invert = settings.invert;

    const portrait = (settings.orientation === 'portrait');
    portraitBtn.classList.toggle('active', portrait);
    landscapeBtn.classList.toggle('active', !portrait);

    ditherNone.classList.toggle('active', settings.dither==='none');
    ditherFS.classList.toggle('active', settings.dither==='fs');
    ditherBayer.classList.toggle('active', settings.dither==='bayer');

    gammaInput.value = String(settings.gamma);
    gammaVal.textContent = (+settings.gamma).toFixed(2);
    invertChk.checked = !!settings.invert;
  }

  function addFiles(fileList) {
    const arr = Array.from(fileList).filter(f => f.type.startsWith('image/') || exOK(f.name));
    if (!arr.length) { warn('No images detected.'); return; }
    let pending = arr.length;
    arr.forEach(f=>{
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = ()=>{
        const item = {
          name: f.name.replace(/\\.(jpe?g|png|webp|gif|bmp)$/i,''),
          url, img,
          view: defaultViewFor(img),
          settings: currentControlsSettings()
        };
        state.files.push(item);
        if (--pending===0) {
          renderThumbs();
          countUpdate();
          if (state.active<0) setActive(0);
          drawPreview();
        }
      };
      img.onerror = ()=>{ warn('Failed to load '+f.name); if(--pending===0) renderThumbs(); };
      img.src = url;
    });
  }

  function renderThumbs() {
    // Desktop
    thumbs.innerHTML = '';
    // Mobile
    thumbsMobile.innerHTML = '';

    state.files.forEach((f,i)=>{
      const makeCard = ()=>{
        const el = document.createElement('div');
        el.className = 'thumb' + (i===state.active ? ' active' : '');
        const im = document.createElement('img'); im.src = f.url; im.alt = f.name;
        const nm = document.createElement('div'); nm.className='name'; nm.textContent=f.name;

        const del = document.createElement('button');
        del.className = 'del'; del.type = 'button'; del.setAttribute('aria-label','Remove');
        del.title = 'Remove image'; del.textContent = '×';
        del.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeAt(i); });

        el.appendChild(im); el.appendChild(nm); el.appendChild(del);
        el.addEventListener('click', ()=>{ setActive(i); /* keep drawer open */ });
        return el;
      };
      thumbs.appendChild(makeCard());
      thumbsMobile.appendChild(makeCard());
    });
  }

  function setActive(i){
    if (i<0 || i>=state.files.length) return;
    state.active = i;
    applySettingsToControlsAndState(state.files[i].settings);
    renderThumbs();
    drawPreview();
  }

  function defaultViewFor(img) {
    const rot=0;
    const tw=state.target.w, th=state.target.h;
    const iw=img.naturalWidth, ih=img.naturalHeight;
    const baseW = (rot%180===0)? iw : ih;
    const baseH = (rot%180===0)? ih : iw;
    const scale = Math.max(tw/baseW, th/baseH);
    const ox = tw/2, oy = th/2;
    return { scale, ox, oy, rot };
  }
  function ensureMinCover(view,img,tw,th){
    const iw=img.naturalWidth, ih=img.naturalHeight;
    const baseW = (view.rot%180===0)? iw : ih;
    const baseH = (view.rot%180===0)? ih : iw;
    const minScale = Math.max(tw/baseW, th/baseH);
    if (view.scale < minScale) view.scale = minScale;
  }

  function removeAt(index){
    if (index < 0 || index >= state.files.length) return;
    const item = state.files[index];
    try {
      if (item && item.img) { try{ item.img.onload=null; item.img.onerror=null; }catch(_){ } }
      if (item && item.url) URL.revokeObjectURL(item.url);
    } catch(_) {}
    state.files.splice(index, 1);
    countUpdate();

    if (state.files.length === 0) {
      state.active = -1;
      renderThumbs();
      drawPreview();
      return;
    }
    let newActive = state.active;
    if (newActive >= state.files.length) newActive = state.files.length - 1;
    if (newActive === index) newActive = Math.min(index, state.files.length - 1);
    setActive(newActive);
  }

  // Preview + processing
  function drawChecker(x=0,y=0,w=canvas.width,h=canvas.height){
    const s=12;
    for(let yy=y|0; yy<y+h; yy+=s){
      for(let xx=x|0; xx<x+w; xx+=s){
        ctx.fillStyle = ((xx/s + yy/s) & 1) ? '#0e1530' : '#0b1126';
        ctx.fillRect(xx,yy,s,s);
      }
    }
  }
  function rasterizeActiveRGBA(w,h){
    if(state.active<0){ return null; }
    const item=state.files[state.active], v=item.view, iw=item.img.naturalWidth, ih=item.img.naturalHeight;
    const cv=document.createElement('canvas'); cv.width=w; cv.height=h; const c=cv.getContext('2d',{willReadFrequently:true});
    c.fillStyle='#fff'; c.fillRect(0,0,w,h);
    c.translate(w/2,h/2); c.beginPath(); c.rect(-w/2,-h/2,w,h); c.clip();
    c.translate(v.ox - w/2, v.oy - h/2); c.translate(w/2,h/2); c.rotate(v.rot*Math.PI/180);
    const drawW=(v.rot%180===0)? iw*v.scale : ih*v.scale; const drawH=(v.rot%180===0)? ih*v.scale : iw*v.scale;
    c.drawImage(item.img, -drawW/2,-drawH/2,drawW,drawH);
    return c.getImageData(0,0,w,h);
  }
  function toGray(img, gamma){
    const d=img.data, n=d.length/4, out=new Float32Array(n), gpow=1/gamma;
    for(let i=0,j=0;i<d.length;i+=4,j++){ let y=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; y=255*Math.pow(y/255,gpow); out[j]=y; }
    return out;
  }
  const bayer8=[[0,48,12,60,3,51,15,63],[32,16,44,28,35,19,47,31],[8,56,4,52,11,59,7,55],[40,24,36,20,43,27,39,23],[2,50,14,62,1,49,13,61],[34,18,46,30,33,17,45,29],[10,58,6,54,9,57,5,53],[42,26,38,22,41,25,37,21]];
  const dithNone=(gr,w,h)=>{const bin=new Uint8Array(w*h); for(let i=0;i<bin.length;i++) bin[i]=(gr[i]>=128)?1:0; return bin;};
  const dithBayer=(gr,w,h)=>{const bin=new Uint8Array(w*h); for(let y=0;y<h;y++)for(let x=0;x<w;x++){const t=(bayer8[y&7][x&7]+0.5)*(255/64); bin[y*w+x]=(gr[y*w+x]>=t)?1:0;} return bin;};
  const dithFS=(gr,w,h)=>{const buf=new Float32Array(gr),bin=new Uint8Array(w*h); for(let y=0;y<h;y++){ for(let x=0;x<w;x++){const i=y*w+x,old=buf[i],nv=(old>=128)?255:0; bin[i]=(nv===255)?1:0; const e=old-nv; if(x+1<w)buf[i+1]+=e*7/16; if(y+1<h&&x>0)buf[i+w-1]+=e*3/16; if(y+1<h)buf[i+w]+=e*5/16; if(y+1<h&&x+1<w)buf[i+w+1]+=e*1/16; }} return bin;};

  function buildProcessedCanvas() {
    const w = state.target.w, h = state.target.h;
    const rgba = rasterizeActiveRGBA(w,h); if(!rgba) return null;
    const gray = toGray(rgba, state.gamma);
    let bin = state.dither==='fs' ? dithFS(gray,w,h) : state.dither==='bayer' ? dithBayer(gray,w,h) : dithNone(gray,w,h);
    const out = new ImageData(w,h);
    const o = out.data;
    for (let i=0, p=0; i<bin.length; i++, p+=4) {
      const on = bin[i] ^ (state.invert ? 1 : 0);
      const v = on ? 255 : 0;
      o[p]=v; o[p+1]=v; o[p+2]=v; o[p+3]=255;
    }
    const pc = document.createElement('canvas'); pc.width = w; pc.height = h;
    pc.getContext('2d', { willReadFrequently:true }).putImageData(out, 0, 0);
    return pc;
  }

  function drawPreview(){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    if (state.active<0) { drawChecker(); return; }
    const tw=state.target.w, th=state.target.h;
    const scaleToCanvas = Math.min(w/tw, h/th);
    const viewW = tw*scaleToCanvas, viewH = th*scaleToCanvas;
    const offX = (w - viewW)/2, offY = (h - viewH)/2;

    drawChecker(offX,offY,viewW,viewH);
    const processed = buildProcessedCanvas();
    if (processed) {
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(processed, offX, offY, viewW, viewH);
      ctx.restore();
    }
    ctx.save();
    ctx.strokeStyle='#2a4a85'; ctx.lineWidth=2/scaleToCanvas;
    ctx.strokeRect(offX, offY, viewW, viewH);
    ctx.restore();
  }

  // Mouse drag + wheel (desktop)
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener('mousedown', (e)=>{ if(state.active<0)return; dragging=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', (e)=>{
    if(!dragging||state.active<0) return;
    const v=state.files[state.active].view, tw=state.target.w, th=state.target.h;
    const scaleToCanvas = Math.min(canvas.width/tw, canvas.height/th);
    v.ox += (e.clientX-lastX)/scaleToCanvas;
    v.oy += (e.clientY-lastY)/scaleToCanvas;
    lastX=e.clientX; lastY=e.clientY; drawPreview();
  });
  canvas.addEventListener('wheel',(e)=>{
    if(state.active<0) return; e.preventDefault();
    const v=state.files[state.active].view, tw=state.target.w, th=state.target.h;
    const delta = Math.sign(e.deltaY)*0.08;
    v.scale *= (1 - delta); ensureMinCover(v, state.files[state.active].img, tw, th); drawPreview();
  }, { passive:false });

  // Touch: drag to pan, pinch to zoom
  let touchMode = { type:null, lastX:0, lastY:0, startDist:0, startScale:1 };
  function getTouchDist(e){
    const t0=e.touches[0], t1=e.touches[1];
    const dx=t0.clientX - t1.clientX, dy=t0.clientY - t1.clientY;
    return Math.hypot(dx,dy);
  }
  canvas.addEventListener('touchstart', (e)=>{
    if(state.active<0) return;
    if (e.touches.length===1){
      touchMode.type='drag'; touchMode.lastX=e.touches[0].clientX; touchMode.lastY=e.touches[0].clientY;
    } else if (e.touches.length===2){
      touchMode.type='pinch'; touchMode.startDist=getTouchDist(e);
      const item=state.files[state.active]; touchMode.startScale=item.view.scale;
    }
  }, { passive:true });
  canvas.addEventListener('touchmove', (e)=>{
    if(state.active<0) return;
    if (touchMode.type==='drag' && e.touches.length===1){
      e.preventDefault();
      const v=state.files[state.active].view, tw=state.target.w, th=state.target.h;
      const scaleToCanvas = Math.min(canvas.width/tw, canvas.height/th);
      const x=e.touches[0].clientX, y=e.touches[0].clientY;
      v.ox += (x - touchMode.lastX)/scaleToCanvas;
      v.oy += (y - touchMode.lastY)/scaleToCanvas;
      touchMode.lastX=x; touchMode.lastY=y;
      drawPreview();
    } else if (touchMode.type==='pinch' && e.touches.length===2){
      e.preventDefault();
      const item=state.files[state.active]; const v=item.view;
      const dist=getTouchDist(e);
      const scale = Math.max(0.1, Math.min(8, touchMode.startScale * (dist / (touchMode.startDist||dist))));
      v.scale = scale; ensureMinCover(v, item.img, state.target.w, state.target.h);
      drawPreview();
    }
  }, { passive:false });
  canvas.addEventListener('touchend', ()=>{ touchMode.type=null; }, { passive:true });

  // Controls (per-image)
  function setOrientation(portrait=true){
    const item = state.files[state.active]; if (!item) return;
    portraitBtn.classList.toggle('active', portrait);
    landscapeBtn.classList.toggle('active', !portrait);
    const newTarget = portrait ? {w:176,h:264} : {w:264,h:176};
    state.target = newTarget;
    item.settings.orientation = portrait ? 'portrait' : 'landscape';
    item.settings.target = { ...newTarget };
    ensureMinCover(item.view, item.img, newTarget.w, newTarget.h);
    drawPreview();
  }
  portraitBtn.addEventListener('click',()=>setOrientation(true));
  landscapeBtn.addEventListener('click',()=>setOrientation(false));

  function setDither(which){
    const item = state.files[state.active]; if (!item) return;
    state.dither = which; item.settings.dither = which;
    ditherNone.classList.toggle('active', which==='none');
    ditherFS.classList.toggle('active', which==='fs');
    ditherBayer.classList.toggle('active', which==='bayer');
    drawPreview();
  }
  ditherNone.addEventListener('click',()=>setDither('none'));
  ditherFS.addEventListener('click',()=>setDither('fs'));
  ditherBayer.addEventListener('click',()=>setDither('bayer'));
  gammaInput.addEventListener('input',()=>{
    const item = state.files[state.active]; if (!item) return;
    state.gamma=parseFloat(gammaInput.value);
    item.settings.gamma = state.gamma;
    gammaVal.textContent=state.gamma.toFixed(2);
    drawPreview();
  }, { passive:true });
  invertChk.addEventListener('change',()=>{
    const item = state.files[state.active]; if (!item) return;
    state.invert = invertChk.checked;
    item.settings.invert = state.invert;
    drawPreview();
  });
  fitBtn.addEventListener('click',()=>{
    const item = state.files[state.active]; if(!item) return;
    item.view = defaultViewFor(item.img);
    ensureMinCover(item.view, item.img, item.settings.target.w, item.settings.target.h);
    drawPreview();
  });
  rotL.addEventListener('click',()=> rotateActive(-90));
  rotR.addEventListener('click',()=> rotateActive(90));
  function rotateActive(delta){
    const item = state.files[state.active]; if(!item) return;
    const v=item.view; v.rot=(v.rot+delta+360)%360;
    ensureMinCover(v, item.img, item.settings.target.w, item.settings.target.h);
    drawPreview();
  }

  // Save / ZIP (per-image settings)
  function pack1bpp(bin,w,h){ const rb=Math.ceil(w/8), pr=((rb+3)&~3), out=new Uint8Array(pr*h);
    for(let y=0;y<h;y++){const s=h-1-y; let byte=0,bit=7,idx=y*pr;
      for(let x=0;x<w;x++){ byte |= (bin[s*w+x]&1)<<bit; if(--bit<0){ out[idx++]=byte; byte=0; bit=7; } }
      if(bit!==7) out[idx++]=byte; while(idx<(y+1)*pr) out[idx++]=0;
    } return out; }
  function bmp1bpp(bin,w,h,invert){ if(invert) for(let i=0;i<bin.length;i++) bin[i]^=1;
    const px=pack1bpp(bin,w,h), off=14+40+8, size=off+px.length; const buf=new ArrayBuffer(size), dv=new DataView(buf); let p=0;
    const w16=v=>{dv.setUint16(p,v,true); p+=2;}, w32=v=>{dv.setUint32(p,v,true); p+=4;};
    dv.setUint8(p++,0x42); dv.setUint8(p++,0x4D); w32(size); w16(0); w16(0); w32(off);
    w32(40); dv.setInt32(p,w,true); p+=4; dv.setInt32(p,h,true); p+=4; w16(1); w16(1); w32(0); w32(px.length);
    dv.setInt32(p,2835,true); p+=4; dv.setInt32(p,2835,true); p+=4; w32(0); w32(0);
    dv.setUint8(p++,0); dv.setUint8(p++,0); dv.setUint8(p++,0); dv.setUint8(p++,0);
    dv.setUint8(p++,255); dv.setUint8(p++,255); dv.setUint8(p++,255); dv.setUint8(p++,0);
    new Uint8Array(buf, off).set(px); return new Blob([buf], {type:'image/bmp'}); }

  const crcTable=(()=>{const t=new Uint32Array(256); for(let n=0;n<256;n++){let c=n; for(let k=0;k<8;k++) c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1); t[n]=c>>>0;} return t;})();
  const crc32=u8=>{let c=~0>>>0; for(let i=0;i<u8.length;i++) c=(c>>>8)^crcTable[(c^u8[i])&0xFF]; return (~c)>>>0;};
  const enc=s=>new TextEncoder().encode(s);
  async function zipStore(files){
    const items=[];
    for(const f of files){ const u8=new Uint8Array(await f.blob.arrayBuffer()); items.push({name:f.name,u8,crc:crc32(u8)}); }
    const names=items.map(it=>enc(it.name));
    let total=0, offs=[], cdSize=0;
    items.forEach((it,i)=>{ offs[i]=total; total += 30 + names[i].length + it.u8.length; });
    items.forEach((it,i)=>{ cdSize += 46 + names[i].length; });
    total += cdSize + 22;
    const out=new Uint8Array(total); let p=0;
    const w16=v=>{ out[p++]=v&255; out[p++]=(v>>>8)&255; };
    const w32=v=>{ out[p++]=v&255; out[p++]=(v>>>8)&255; out[p++]=(v>>>16)&255; out[p++]=(v>>>24)&255; };
    items.forEach((it,i)=>{
      w32(0x04034b50); w16(20); w16(0); w16(0); w16(0); w16(0);
      w32(it.crc); w32(it.u8.length); w32(it.u8.length); w16(names[i].length); w16(0);
      out.set(names[i], p); p+=names[i].length; out.set(it.u8, p); p+=it.u8.length;
    });
    const cdStart=p;
    items.forEach((it,i)=>{
      w32(0x02014b50); w16(20); w16(20); w16(0); w16(0); w16(0); w16(0);
      w32(it.crc); w32(it.u8.length); w32(it.u8.length);
      w16(names[i].length); w16(0); w16(0); w16(0); w16(0); w32(0); w32(offs[i]);
      out.set(names[i], p); p+=names[i].length;
    });
    const cdEnd=p;
    w32(0x06054b50); w16(0); w16(0); w16(items.length); w16(items.length);
    w32(cdEnd-cdStart); w32(cdStart); w16(0);
    return new Blob([out], {type:'application/zip'});
  }

  function saveBlob(blob, filename){
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename;
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
  }

  document.getElementById('saveOne').addEventListener('click', ()=>{
    if(state.active<0) return warn('No image selected.');
    const {w,h}=state.target;
    const rgba=rasterizeActiveRGBA(w,h); if(!rgba) return;
    const gray=toGray(rgba,state.gamma);
    let bin = state.dither==='fs' ? dithFS(gray,w,h) : state.dither==='bayer' ? dithBayer(gray,w,h) : dithNone(gray,w,h);
    const bmp=bmp1bpp(bin,w,h,state.invert);
    saveBlob(bmp, state.files[state.active].name + '.bmp');
  });

  document.getElementById('saveZip').addEventListener('click', async ()=>{
    if (!state.files.length) return warn('No images loaded.');
    const files=[];
    const saved = { active: state.active, target:{...state.target}, dither:state.dither, gamma:state.gamma, invert:state.invert };
    for (let i=0;i<state.files.length;i++){
      const item = state.files[i];
      applySettingsToControlsAndState(item.settings);
      state.active = i;
      const {w,h} = state.target;
      const rgba=rasterizeActiveRGBA(w,h); if (!rgba) continue;
      const gray=toGray(rgba,state.gamma);
      let bin = state.dither==='fs' ? dithFS(gray,w,h) : state.dither==='bayer' ? dithBayer(gray,w,h) : dithNone(gray,w,h);
      files.push({ name: item.name + '.bmp', blob: bmp1bpp(bin,w,h,state.invert) });
      await new Promise(r=>setTimeout(r,0));
    }
    applySettingsToControlsAndState(saved);
    state.active = saved.active;
    renderThumbs(); drawPreview();
    const zip=await zipStore(files);
    saveBlob(zip, `t5_bmps.zip`);
  });

  // Drag/drop & pickers (desktop + mobile)
  function wireDrop(zone, input){
    zone.addEventListener('click', ()=> input.click());
    zone.addEventListener('dragover', (e)=>{ e.preventDefault(); zone.classList.add('hover'); });
    zone.addEventListener('dragleave', ()=> zone.classList.remove('hover'));
    zone.addEventListener('drop', (e)=>{ e.preventDefault(); zone.classList.remove('hover'); addFiles(e.dataTransfer.files); });
  }
  wireDrop(drop, fileInput);
  wireDrop(dropMobile, fileInputMobile);
  fileInput.addEventListener('change', (e)=> addFiles(e.target.files));
  fileInputMobile.addEventListener('change', (e)=> addFiles(e.target.files));

  // Keyboard helpers
  window.addEventListener('keydown',(e)=>{
    if (e.key==='ArrowLeft') setActive(Math.max(0,state.active-1));
    if (e.key==='ArrowRight') setActive(Math.min(state.files.length-1,state.active+1));
  });
  window.addEventListener('keydown',(e)=>{
    const tag = (document.activeElement && document.activeElement.tagName) || '';
    const typing = /INPUT|TEXTAREA|SELECT/.test(tag);
    if ((e.key === 'Delete' || e.key === 'Backspace') && !typing) {
      if (state.active >= 0) { removeAt(state.active); e.preventDefault(); }
    }
  });

  // Init
  applySettingsToControlsAndState({
    orientation:'portrait', target:{w:176,h:264}, dither:'none', gamma:1.0, invert:false
  });
  countUpdate();
})();
</script>
</body>
</html>
